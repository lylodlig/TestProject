
[TOC]


# Java基础
## 1. 九种基本数据类型的大小，以及他们的封装类
byte(8)、short(16)、int(32)、long(64)、float(32)、double(32)、short(16)、boolean(32?)
> extend:byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化）


## 2. Switch能否用string做参数
jdk1.7之前不行，只能int、short、byte、char
jdk1.7之后可以，，支持整形，枚举类型，boolean，字符串

## 3. equals与==的区别
==是判断两边值是否相等，基本类型就比较值是否相等，引用类型比较引用的值是否相等
equals()是Object的方法，在Object中就是==来比较，在Object的一些子类中可能覆盖这个方法，比如String就是比较内存是否相等

## 4. Object有哪些公用方法？
clone()、getClass()、toString()、finlize()、equals()、hashCode()、wait()、notify()、notifyAll()
extend:clone方法实现对象的拷贝，需要实现Cloneable接口，重写clone方法，调用super.clone()实现，拷贝出来是个新的对象，这是浅拷贝；深拷贝需要拷贝里面的引用对象

## 5. Java的四种引用，强弱软虚，用到的场景
强引用：平常使用的都是强引用，内存空间不足也不会回收
软引用（SoftReference）：内存空间足不会回收，不足会回收，使用场景可以做缓存，比如大量图片，使用软引用存储图片对象，放到一个集合中，每次从这里面取
弱引用（WeakReference）：不管内存空间是否足够，只要垃圾回收扫描到久回收。使用场景，在解决Handler的内存泄漏时会使用（Activity被销毁，没有强引用指向它，handler对Activity是弱引用，Activity就会顺利回收）。
虚引用：一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。用于跟踪对象的垃圾回收活动，必须和引用队列联合使用

## 6. Hashcode的作用
hashCode()方法返回对象的hash值，提高查找的快捷性，在散列存储结构中确定对象的存储地址，equals()方法相同，hashCode一定要相同

## 7. ArrayList、LinkedList、Vector的区别
ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。
Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。
LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。

## 8. String、StringBuffer与StringBuilder的区别
运行速度:StringBuilder > StringBuffer > String
String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的
StringBuilder是线程不安全的，而StringBuffer是线程安全的
String：适用于少量的字符串操作的情况
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

string不可变原因，字符串常量池可以实现，节约内存。安全性问题，线程安全问题，防止恶意修改字符串。保证哈希码的唯一性，频繁使用时不会反复的创建
## 9. Map、Set、List、Queue、Stack的特点与用法
Map是键值对集合，键不能重复，值可以，采用哈希散列，查找快
Set、List继承与Collection，Set不可有重复元素，内部排序，List可以有重复元素，进入先后有序保存
Stack类继承与Vector，Vector继承与List，实现了一个后进先出的栈
Queue接口，先进先出原则，LinkedList实现了Queue接口，有offer、poll等方法，可通过返回值来判断是否成功

## 10. HashMap和HashTable的区别
都实现了Map接口，HashTable是线程安全的，HashMap不是；HashMap允许null的key，HashTable不可以

## 11. HashMap和ConcurrentHashMap的区别，HashMap的底层源码
Hash就是散列，通过散列算法输出固定长度的值
HashMap本质是数组加链表，根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，哈希冲突，就用链表串起来，新插入的在前面。
ConcurrentHashMap在HashMap的基础上将数据分为多个segment，默认16个，然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。并发访问的时候用。
HashMap是由数组和链表组成的，数组是主体，链表是为了解决哈希冲突而存在的；jdk1.8之后如果相同的hashCode超过8，将会采用红黑树来存储
HashMap是通过put和get方法来存取数据的，put时首先会调用hashCode方法得到哈希值，找到bucket位置来存储Entry对象，如果hashCode相同，代表bucket位置相同，这样会产生冲突，采用链表来解决，会存储到LinkedList中；调用get方法时，如果两个hashCode相同那么会遍历LinkedList找出对象，再比较equals方法，得到所需对象；
如果HashMap超过了负载因子定义的容量，那么会创建一个原来两倍大小的bucket数组，调整map大小，把原来对象放入新的bucket数组中。当多线程情况下调整大小，会出现条件竞争

## 12. TreeMap、HashMap、LindedHashMap的区别
TreeMap内部会根据key值进行升序排序，也可以自定义排序器
HashMap是无序的
LinkedHashMap是可以保证顺序输入

## 13. Collection包结构，与Collections的区别
Collection是集合类的顶级接口，Set、List、Queue继承于Collection，Set的子类有HashSet、LinkedHashSet、TreeSet等，List的子类有ArrayList、LinkedList、Vector
Collections是一个集合的帮助类，提供一些操作集合的方法，比如sort排序，shuffle随机排序，binarySearch查找指定元素，reverse反转顺序，replaceAll替换某元素，rotate集合中的元素向后移动m个位置

## 14. try catch finally，try里有return，finally还执行么
肯定会执行。finally{}块的代码只有在try{}块中包含遇到System.exit(0);之类的导致Java虚拟机直接退出的语句才会不执行。
当程序执行try{}遇到return时，程序会先执行return语句，但并不会立即返回——也就是把return语句要做的一切事情都准备好，也就是在将要返回、但并未返回的时候，程序把执行流程转去执行finally块，当finally块执行完成后就直接返回刚才return语句已经准备好的结果。

## 15. Synchronized关键字
Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。
Synchronized主修修饰对象为以下三种：

1. 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。

2. 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。

3. 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。

Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。

Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。

简单来说 就是 Synchronized代码块更加灵活精确。

问题1 ：不能同步
问题2：能同步

## 16. 泛型
泛型，也就是参数化类型，泛型可用于类、接口、方法
一些运行期间的错误可以提前到编译期间，如果用Object编译器可能不会提示错误；泛型只在编译期间有效，泛型的信息不会到运行阶段
提高Java程序类型安全；消除类型转换；代码简洁方便
在编译期间会泛型擦除

## 17. 面向对象的三个特征和含义
继承/封装/多态
封装：把事物的属性和行为封装到对象里面，对象对外公布需要公布的属性
继承：子类可以继承父类的属性和行为
多态：是指父对象的某一行为能在多个子对象中有不同的表现，实现多态的技术是动态绑定，是根据引用对象的实际类型调用相应的方法。
多态的三个条件：继承/重写/父类引用指向子类对象

> 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定。让引用变量在运行时绑定到不同的代码上，这就是java的多态性

## 18. override和overload
override是子类重写父类的方法，具有相同的方法名参数返回值，final、private方法不能重写
overload是发生在一个类中，参数类型、个数、顺序至少有一个不同

## 19. interface和abstract 的区别和相同点
含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类中可以有普通成员变量，接口中没有普通成员变量
3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类。

## 20. Static class 与non static class的区别
内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。
非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。
一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法

## 21.volatile
- volatile关键字的作用

	- 保证内存的可见性
	- 防止指令重排
	- 注意：volatile并不能保证操作的原子性

- 内存可见性
volatile保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本，所以volatile关键字的作用之一就是保证变量修改的实时可见性。

- 当且仅当满足以下所有条件时，才应该使用volatile变量

	- 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
	- 该变量没有包含在具有其他变量的不变式中。

- volatile使用建议

在两个或者更多的线程需要访问的成员变量上使用volatile。当前访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。

由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。

## 22.java类加载过程
- 类加载器会把class文件加载到内存中，只有加载到内存中才能够被使用。
- 双亲委托模式，每一个类加载器都有一个父加载器，每当加载一个class文件时，会向上进行搜索，先从父加载器中寻找，有就直接使用，没有才会自己加载。这样的好处在于可以避免重复加载；另一方面可以避免恶意加载，比如String是由系统加载的，如果我们不这样，那么可以直接写一个类加载器来自己加载了。
- 在搜索类时，不仅会通过全类名来判断是否相同，还要验证是否是同一个类加载器来加载的。
类的加载过程分为五个阶段：加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载

1. 加载：通过一个类的全限定名来获取定义此类的二进制字节流；将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口
2. 链接：验证：确保被加载类的正确性；准备：为类的静态变量分配内存，并将其初始化为默认值；解析：把类中的符号引用转换为直接引用；
3. 初始化 ：
	（1）类什么时候才被初始化
　　1）创建类的实例，也就是new一个对象
　　2）访问某个类或接口的静态变量，或者对该静态变量赋值
　　3）调用类的静态方法
　　4）反射（Class.forName(“com.lyj.load”)）
　　5）初始化一个类的子类（会首先初始化子类的父类）
　　6）JVM启动时标明的启动类，即文件名和类名相同的那个类
（2）类的初始化顺序
　　1）如果这个类还没有被加载和链接，那先进行加载和链接
　　2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）
　　3）加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。
　　4）总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法


## 23.java的线程如何实现
1.继承Thread类，重写run方法
2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
3.通过Callable和FutureTask创建线程
4.通过线程池创建线程

## 24.ArrayList 如何删除重复的元素或者指定的元素
```
 HashSet h = new HashSet(arlList);
        arlList.clear();
        arlList.addAll(h);
```
还可以使用迭代器来实现

## 25.Java 中内部类为什么可以访问外部类
因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去

## 26.接口的意义
正因为接口和抽象类才赋予了Java强大的面向对象的能力
更加的规范，项目的一些架构大多都需要接口来实现，来统一
扩展性好，定义一个功能的接口，可以通过不同的方式来实现它
可以使一些模块降低耦合

## 27.抽象类的意义
抽象类是把具有相同性质的东西抽象出来，抽象类是不能实例化的，具有相同属性的类出现时就可以继承抽象类，来继承它的这些方法，利于代码的维护

## 28.内部类的作用
内部类可以很好的对外隐藏，可以使用private等来修饰，也可以访问外部类的

## 29.父类的静态方法能否被子类重写，为什么？
父类的静态方法是不能被子类重写的，其实重写只能适用于实例方法，不能用于静态方法；因为静态方法只与类相关，不与具体实现相关

## 30.什么导致线程阻塞
该线程放弃CPU的使用，暂停运行
1. 一般线程中的阻塞：调用sleep方法；同步代码无法获取到同步锁；调用wait方法，等待唤醒；一些IO操作等待资源
2. Socket客户端服务端的阻塞

## 31.泛型中extends和super的区别
 ? extends T 限定参数类型的上界：参数类型必须是T或T的子类型

 ? super T 限定参数类型的下界：参数类型必须是T或T的超类型

## 32.多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据
- 调用线程的join方法，变为并行执行
- 使用CountDownLatch，每个线程执行完后减1，在wait方法后面执行合并操作
- 使用CyclicBarrier，和CountDownLatch类似
- 使用线程池的awaitTermination方法，

## 33.线程种类
用户线程和守护线程
守护线程是为了其他线程服务的，当程序只剩下守护线程，那么也就退出了

## 34.线程池
好处：重用线程池中的线程，避免创建销毁带来的开销；能有效控制线程池的最大并发数；能够对线程进行管理
Java中已经提供了创建线程池的一个类：Executor。ThreadPoolExecutor是线程池的实现，提供了一系列参数来配置线程池。

参数：
- corePoolSize：核心线程数数量，没用的时候也不会被回收。
- maximumPoolSize：就是线程池中可以容纳的最大线程的数量
- keepAliveTime:非核心线程空闲状态可存活的时间
- workQueue：等待队列，任务可以储存在任务队列中等待被执行
- threadFactory:创建线程的工厂
- RejectedExecutionHandler：一种拒绝策略，可以在任务满了拒绝某些任务，有四种拒绝策略

任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果不是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。


- FixedThreadPool
	线程数量固定的线程池，空闲状态不会被回收，通过newFixedThreadPool创建
- CachedThreadPool
	最大线程数是Integer.MAX_VALUE，当没有空闲线程时，就会创建新的线程来处理任务，空闲线程有超时机制60s之后就会回收
- ScheduledThreadPool
	核心线程数是固定的，非核心线程数没有限制，当非核心线程空闲时就会立即回收
- SingleT'hreadPool
	只有一个核心线程，保证加入的任务都顺序执行




## 35.线程的几种状态
1. 新建状态：新建一个线程
2. 就绪状态：调用了start方法，等待CPU的调度
3. 运行状态：执行程序
4. 阻塞状态：失去CPU的使用权，停止运行
	调用wait方法进去阻塞，需要notify才能唤醒；获取同步锁被其他线程占用进入阻塞状态；调用sleep，join等或者IO操作会进入阻塞状态
5. 线程执行完或者异常退出

## 36.static和final的区别和用途
static:

- 修饰变量：静态变量随着类的加载时就自动完成初始化，内存中只有一个，且虚拟机只会为它分配一次内存，所有类共享静态变量。

- 修饰方法：静态方法不依赖于于任何实例对象，被类的所有实例共享。静态方法可以直接通过类名调用，静态方法必须实现，不能用abstract修饰。

- 修饰代码块：在类加载完之后会自动执行的代码块。

- 代码执行顺序：父类静态代码块--->子类静态代码块--->父类非静态代码块--->父类构造方法--->子类非静态代码块--->子类构造方法

final：
修饰类和方法，则不能被继承不能被子类修改；修饰变量、常量则不能被修改

## 37.什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？
- 什么是线程池：
线程池顾名思义就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

- 设计一个动态大小的线程池，如何设计，应该有哪些方法：

	- 一个线程池应包括以下四个基本组成部分：

	- 线程管理器(ThreadPool):用于创建并管理线程池，包括创建线程池，销毁线程池，添加任务；

	- 工作线程(PoolWorker)：线程池中线程，在没有任务处于等待状态，可以循环的执行任务；

	- 任务接口(Task):每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完成后的收尾工作，任务的执行状态等；

	- 任务队列(TaskQueue):用于存放没有处理的任务，提供一种缓冲机制；

- 所包含的方法：

	- private ThreadPool() 创建线程池

	- public static ThreadPool getThreadPool() 获得一个默认线程个数的线程池

	- public void execute(Runnable task) 执行任务，其实只是把任务加入任务队列，什么时候执行由线程池管理器决定

	- public void execute(Runnable[] task) 批量执行任务，其实只是把任务加入任务队列，什么时候执行由线程池管理器决定

	- public void destroy() 销毁线程池，该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁

	- public int getWorkThreadNumber() 返回工作线程的个数

	- public int getFinishedTaskNumber() 返回已完成任务的个数，这里的已完成指的是出了任务队列的任务个数，可能该任务并没有实际执行完成

	- public void addThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时，添加线程池中线程的个数

	- public void reduceThread在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一值时，减少线程池中线程的个数




# JVM
### 1. 内存模型以及分区，需要详细到每个区放什么
**栈区**分为java虚拟机栈和本地方法栈（本地方法服务，执行native方法，和java虚拟机栈类似）
我们说的栈内存主要是java虚拟机栈，它是线程私有，生命周期与线程相同，每一个方法执行都会创建一个栈帧，用于存放局部变量表，操作栈等
通常所说的栈是局部变量表部分，存放编译期间的8种基本类型，对象引用
**堆区**堆被所有线程共享，虚拟机启动时创建
**方法区**被所有线程共享，类信息，存放常量，静态变量等，运行时常量池是方法区的一部分（存放编译期间生成的字面量和符号引用，运行期间也可以把新的变量放入常量池中）
**程序计数器**每条线程有独立的程序计数器，用于指示当前线程所执行的字节码到了哪一行，是线程私有的，这个区域不存在OOM

## 2. 对象创建方法，对象的内存分配，对象的访问定位
- 对象创建方法
JVM遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、连接和初始化过。如果没有，那必须先先行相应的类的加载过程。类检查通过后，虚拟机为对象分配内存空间
- 对象内存分配
对象内存大小在类加载完成后就确定，为对象分配内存有两种方式：
1. 指针碰撞：如果堆中内存是规整的，把所用过的内存放一边，没用过的放一边，中间放着一个指针作为指示器，分配内存就是把指针向空闲的内存一边移动一段与对象大小相等的距离
2. 空闲列表：如果不是绝对规整的，使用的和未使用的相互交错，这时虚拟机维护一个列表，记录哪些内存是可用的，从列表中找到足够的内存分配给对象，更新列表

> 并发的线程安全问题，虚拟机频繁创建对象可能存在线程安全问题，两种解决方案：对分配内存空间的动作进行同步——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，（TLAB ，Thread Local Allocation Buffer）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。

- 对象访问定位
程序要通过栈上的reference数据来操作堆上的具体对象。对象的访问方式有使用句柄和直接指针。
使用句柄：java堆会划分一块内存作为句柄池，reference中存的是对象的句柄地址，而句柄中包含了对象的实例数据的地址和类型数据的地址（在方法区）。  优点：对象被移动，reference不用修改，只会改变句柄中保存的地址。
使用直接指针：reference中存的是对象的地址，对象中分一小块内存保存类型数据的地址。优点：速度快。

## 3.GC的两种判定方法：引用计数与引用链
给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，当对象不能再被使用，在下次进行GC时就会被收集。
引用计数法的缺点是很难解决对象之间相互循环引用的问题，当对象objA和对象objB之间相互引用，此时它们的引用计数器都不为0，即使这两个对象没有再被其它地方引用，也不会被当作垃圾收集，所以主流的Java虚拟机里面没有选用引用计数算法来管理内存
通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时（用图论的话来说，就是从GC Roots到这个对象不可达），则证明此对象是不可用的，此时它们会被判定为可回收对象。
在Java语言中，可作为GC Roots的对象包括下面几种：
1、虚拟机栈（栈帧中的本地变量表）中引用的对象；
2、方法区中类静态属性引用的对象；
3、方法区中常量引用的对象；
4、本地方法栈中JNI引用的对象；

## 4.java 虚拟机的特性
ava语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。


# 操作系统
## 1. 进程和线程的区别
进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
同一个进程中可以包括多个线程，并且线程共享整个进程的资源，一个进行至少包括一个线程。
进程结束它拥有的线程都销毁
线程是轻量级的进程，创建和销毁都比进程快很多

## 2. 死锁的必要条件，怎么处理死锁
死锁是指多个进程无限等待对方占用的资源才能进行下去的状态，没有外力作用永远处于等待状态
互斥条件：某个资源在一段时间内只能由一个进程使用
不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能自行释放
请求和保持条件：进程至少已经保持一个资源，但又提出新的资源请求，而该资源又被其他进程占用
循环等待条件：若干进程之间形成一种首尾相接的循环等待资源关系，如p1等p2,p2等p3,p3等p1
处理死锁的方法：预防死锁、避免死锁、检测死锁、解除死锁
预防死锁的方法：进程创建时一次性申请所有需要的资源；每个进程提出新的资源申请时，释放旧的；进程进一步申请资源时被拒绝时，释放最初占用的资源；进程申请另一个进程的资源，根据优先级让它释放；把资源编号，按照顺序提出申请资源
死锁的解除：挂起某些死锁进程，把资源分配给其他死锁进程；强制撤销死锁的进程

```
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

## 3.常见编码方式； utf-8 编码中的中文占几个字节；数字几个字节
一个utf8数字占1个字节，一个utf8英文字母占1个字节，少数是汉字每个占用3个字节，多数占用4个字节。

# 数据结构和算法等
## 1. 冒泡排序
每次比较相邻的两个元素，大的放后面，小的放前面，一遍之后最大的数就在最后面，大数下层到下面，小数冒到前面
```
public static int[] bubble(int[] array) {
		int n=array.length;
		for (int i = 0; i < n-1; i++) {
			for (int j = 0 ; j < n-i-1; j++) {
				if (array[j] > array[j+1]) {
					int temp = array[j+1];
					array[j+1] = array[j];
					array[j] = temp;
				}
			}
		}
		return array;
	}
```
改进：如果又一次循环，没有发生位置交换，说明已经排好，直接退出循环

## 2. 链表与数组
两者都是数据结构的一种，数组是申请的一块连续的内存空间，并且是在编译阶段就要确定空间大小的，同时在运行阶段是不允许改变的，所以它不能够随着需要的改变而增加或减少空间大小

链表则是动态申请的内存空间，是非连续的内存空间，逻辑顺序是通过指针按顺序连接起来的，需要时申请，所以增加删除数据比数组灵活。链表是由一系列结点组成的，一个结点包括存储的数据和指向下一个结点的引用

栈只能在一段进行插入和删除的线性表，进行插入和删除的一端叫栈顶，另一端为栈底，栈最大的一个特点就是先进后出(FILO—First-In/Last-Out),

队列 是一种先进先出(FIFO—first in first out)的数据结构

## 3. 链表的删除、插入、反向
在链表类内部创建一个Node类，它包含两个属性，当前对象和下一个节点的引用
插入：如果根节点不为空，调用Node的add方法，如果next为空，那么next就是插入的节点，如果不为空，就调用next的add方法；如果指定位置插入，找到插入位置的前一个Node，把它的next置为要插入的Node，插入Node的next设置为前一个的next
删除：要要删除的节点的上一个节点的next设置为要删除节点的next，当然这里有一些非空的判断
反向：主要思想就是把相邻的箭头指向反过来就OK了，定义两个变量当前Node为current，上一个Node为pre，写一个while循环，把current的next保存到temp中，接着把current的next指向pre上一个Node，把current赋值给pre，当前的变为上一个，把之前temp中存储的next赋值给current
```
 Node current=head;
        Node pre=null;
        while(current.next!=null){
            temp=current.next;
            current.next=pre;
            pre=current;
            current=temp;

        }
```

##  4.Hash表的hash函数，冲突解决方法有哪些
http://blog.csdn.net/duan19920101/article/details/51579136
哈希表是通过关键字来访问的数据结构，把关键字映射到表中一个位置来访问，提高访问速度。这个映射函数就是哈希函数，采用散列技术将记录存储在一块连续的存储空间中

## 5.单例模式
有时需要某个类只有一个实例存在，作为全局对象，协调整体，避免产生多个对象耗费资源
- 懒汉式
	声明一个静态变量，使用时进行初始化
```
	public class Singleton{
	private static Singleton instance;
	private Singleton(){}
	public static synchronized Singleton getInstance(){
		if(instance==null){
			instance=new Singleton();
		}
		return instance;
	}
	}
```
	为了线程安全getInstance方法是被synchronized修饰的，每次都会进行同步造成不必要的开销

- Double Check Lock（DCL）
	优点在于需要时初始化，线程安全，getInstance方法不加同步锁
```
	public class Singleton{
	private static Singleton instance;
	private Singleton(){}
	public static  Singleton getInstance(){
		if(instance==null){
		synchronized（Singleton.class）{
			if(instance==null)
				instance=new Singleton();
				}
			}
		return instance;
		}
	}
```
- 静态内部类实现单利
```
	public class Singleton{
	private Singleton(){}
	public static  Singleton getInstance(){
		return SingleHolder.instance;
		}
	private static class SingletHolder{
		private static final Singleton instance=new Singleton();
	}
	}
```

## 6.快排
把一组数据以一个基准数分成两部分，前一部分全部比这个基准数小，后一部分全部比基准数大；然后分别对这两部分递归使用这种方式来排序

> 把最左边的数作为基准，从最右边向左边开始比较，如果有小于这个基准的数就交换位置，这时再从左边向右边比较，遇到比这个基准小的，交换位置，一直这样交替对比，最后就会得出基准左边全部都比基准小，右边全部都比基准大，这时再把这两边分为两部分递归进行刚才的过程


```
 private static void kuaipai(int start, int end, int[] array) {
        if (start > end) {
            return;
        }
        int i = start;
        int j = end;
        int base = array[start];//最左边的作为基准数
        while (i < j) {
            while (array[j] >= base && i < j)//先从右往左找，直到找到小于基准数的下标为j的为止
                j--;
            while (array[i] <= base && i < j)//再从左往右找，知道找到大于基准数
                i++;
            //把这两个数交换位置，然后继续下一次循环，直到i和j相遇
            if (i < j) {
                int temp = array[j];
                array[j] = array[i];
                array[i] = temp;
            }
        }
        //当i和j相遇时，结束了循环，把基准数放到i的位置，实现了左边所有比基准数小，右边所有比基准数大
        int temp = array[start];
        array[start] = array[i];
        array[i] = temp;

        //再次对左边和右边采用相同的方法递归实现
        kuaipai(start, i - 1, array);
        kuaipai(i + 1, end, array);
    }
```

## 7.选择排序
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
```
public static int[] selectSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[minIndex] > array[j]) {
                    minIndex = j;
                }
                //把最小的与未排序第一个交换
                int temp = array[minIndex];
                array[minIndex] = array[i];
                array[i] = temp;
            }
        }
        return array;
    }
```

## 8.Builder模式
将一个复杂对象的构造与它的表示进行分离，构建有不同的表示；用于构造特别复杂的对象，参数特别多

## 9.原型模式
当一个类的初始化十分复杂，需要消耗过多资源，new一个对象时需要分成繁琐的数据准备；原型模式就是通过拷贝来创建对象，具体时通过Cloneable接口实现，浅拷贝和深拷贝

## 10.工厂模式
定义一个用于创建对象的接口，让子类决定实例化哪个类，还是一些复杂对象的创建需要用到工厂模式。主要分为四大模块，抽象工厂，具体工厂。抽象产品，具体产品，需要哪一个类就传入所需要的参数就行了，这样依赖抽象的架构，有很好的扩展性

## 11.桶排序
有多少个种类就造多少个桶，然后把这些数分别放入对应的桶中，每一个桶初始化都是0，每增加一个桶里的数量就加1，最后把桶按照顺序输出出来就行了

## 12.DCL单例是绝对安全的吗？如果不是怎么解决
如果语句之间没有直接依赖，jvm会指令重排，对代码进行优化，


# 计算机网络
## 1. OSI与TCP/IP各层的结构与功能
OSI(open system interconnection,开放系统互连)，逻辑上的定义，每一层都要相关对应的设备，建立七层模型主要目的是为了解决各种网络互连所遇到的兼容问题，帮助不同类型的主机实现数据传输
![image](http://images2015.cnblogs.com/blog/801914/201509/801914-20150917125640429-2040782810.png)
![](http://s6.51cto.com/wyfs01/M02/31/33/wKioOVJpyoiwv5o-AAFl51p0GRU008.jpg)

## 2. TCP/UDP区别
TCP是面向连接；UDP是无连接的，发送数据前不需要连接
TCP提供可靠的服务，无差错，按照顺序到达；UDP是不可靠的
TCP是面向字节流；UDP是面向报文的，UDP没有拥塞控制，网络拥塞时不会使源主机发送频率降低，对实时应用比较有用
TCP要求的系统资源多，UDP要少一些
UDP的优势在于简单，传输速度快，实时性高；

## 3.HTTP和HTTPS
- HTTPS相比于HTTP来说更加的安全，是在HTTP的基础上增加了TLS或SSL协议，依靠证书验证身份并提供通信加密
- HTTPS缺省工作在TCP协议443端口，而HTTP在80端口

HTTP是明文传输的，可能存在一些问题：重要数据被获取、通信双方被伪造、数据被篡改
HTTPS是在HTTP与TCP之间再加上一层SSL/TLS

> http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误

## 4.DNS劫持和Http劫持
- DNS劫持就是劫持了DNS服务器，修改域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP
- HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文

## 5.浏览器输入地址到返回结果发生了什么
- 域名解析
- TCP的三次握手
- 建立TCP连接后发起HTTP请求
- 服务器响应HTTP请求
- 浏览器解析html代码
- 同时请求html代码中的资源（如js、css、图片等）
- 最后浏览器对页面进行渲染并呈现给用户

## 6.HTTP协议
HTTP也就是超文本传输协议，是建立在TCP的基础上的，是一种无状态无连接的协议，每一次HTTP请求都是一次新的连接，每次连接结束后就会断开，并不会记住状态

报文是HTTP交互的方式，分为请求报文和响应报文。

HTTP请求格式:

- 请求行: 请求方法（GET/POST/DELETE/PUT/HEAD）、URI路径、HTTP版本号
- 请求头: 缓存相关信息（Cache-Control，If-Modified-Since） 客户端身份信息（User-Agent）等键值对信息
- 消息体: 客户端发给服务端的请求数据，这部分数据并不是每个请求必须的(post put)

HTTP响应格式：

- 状态行：有HTTP协议版本号，状态码和状态说明三部分构成。
- 响应头：用于说明数据的一些信息，比如数据类型、内容长度等键值对。
- 消息体：服务端返回给客户端的HTML文本内容。或者其他格式的数据，比如：视频流、图片或者音频数据。

### Http缓存
当我们发起一个http请求后，服务器返回所请求的资源，这时我们可以将该资源的副本存储在本地，这样当再次对该url资源发起请求时，我们能快速的从本地存储设备中获取到该url资源。

当发送一个请求时，时候使用缓存资源，会进行一个新鲜度检测，达到一定时间就会在服务器上面查看资源是否改变。在服务器返回的响应报文中的Cache-Control:max-age去设置这个时间。





## 7.session与cookie的区别
Session是存放在服务器的，第一次请求时服务器会生成一个Session和SessionID来标识这个Session，再次请求时会带上这个SessionID请求，过一段时间这个Session会销毁
cookie是保存在客户端的，cookie可以保存SessionID，Session比cookie更可靠

## 8.TCP协议
TCP协议的特点是面向连接、全双工、可靠的、面向字节流传输；也就是说要使用TCP传输需要先建立连接，传输完成后关闭连接，只要建立连接后双方都能相互发送数据，并且传输的是可靠的数据。

TCP建立连接需要三次握手

1. 客户端把同步标志位SYN设置为1，随机生成一个发送序号seq=j，把该数据包发送给服务端，这时不携带数据，客户端进入已发送状态（SYN_SEND），等待服务端确认
2. 服务端收到客户端的SYN包，由标志位知道客户端请求连接，这时把SYN（同步标志位）、ACK（确认标志位）置为1，确认序号ack=j+1，再随机生成一个发送序号seq=k，把它发送给客户端，服务端进入同步已接收状态（SYN_RCVD）
3. 客户端收到数据包，检查ack是否等于j+1，ACK是否为1，正确后把ack设置为k+1，ACK设置为1，发送给服务端，服务端收到后再次验证ack是否为k+1,ACK是否为1，验证成功双方都进入已创建状态（ESTABLISHED）

防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源

四次挥手，断开TCP连接总共需要发送四次数据包确认断开

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。


2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

  这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。


## 9.OAuth
OAuth是一个用于授权第三方获取相应资源的协议。与以往的授权方式不同的是，OAuth的授权能避免用户暴露自己的用户密码给第三方，从而更加的安全。OAuth协议通过设置一个授权层，以区分用户和第三方应用。用户本身可以通过用户密码登陆服务提供商，获取到账户所有的资源。而第三方应用只能通过向用户请求授权，获取到一个Access Token，用以登陆授权层，从而在指定时间内获取到用户授权访问的部分资源。

一个OAuth授权的流程主要可以分为6步：

1. 客户端向用户申请授权。

2. 用户同意授权。

3. 客户端通过获取的授权，向认证服务器申请Access Token。

4. 认证服务器通过授权认证后，下发Access Token。

5. 客户端通过获取的到Access Token向资源服务器发起请求。

6. 资源服务器核对Access Token后下发请求资源。


## 10.HTTPS
传统的Http协议是一种应用层的传输协议，Http直接与TCP协议通信，其本身存在一些缺点。Https则通过增加的SSL、TLS，支持对通信内容的加密，通信双方身份的验证。

SSL\TLS的加密方式则是结合了两种加密方式的优点。首先采用非对称秘钥加密，将一个对称秘钥使用公开秘钥加密后传输到对方。对方使用私有秘钥解密，得到传输的对称秘钥。之后双方再使用对称秘钥进行通信。这样即解决了对称秘钥加密的秘钥传输问题，又利用了对称秘钥的高效率来进行通信内容的加密与解密。

## 11.OkHttp的缓存
OkHttp的缓存流程是遵循了Http的缓存，使用了CacheInterceptor实现
1.从接收到的请求中，解析出Url和各个首部。
2. 查询本地是否有缓存副本可以使用。

3.如果有缓存，则进行新鲜度检测，如果缓存足够新鲜，则使用缓存作为响应返回，如果不够新鲜了，则构造条件请求，发往服务器再验证。如果没有缓存，就直接将请求发往服务器。

4.把从服务器返回的响应，更新或是新增到缓存中。

通过cache指定缓存的大小和文件夹，Response的消息有两种类型，CacheResponse和NetworkResponse。CacheResponse代表从缓存取到的消息，NetworkResponse代表直接从服务端返回的消息。

控制缓存的消息头往往是服务端返回的信息中添加的如”Cache-Control:max-age=60”。
OkHttp可以通过拦截器得到request和response
addInterceptor:设置应用拦截器，主要用于设置公共参数，头信息，日志拦截等
addNetworkInterceptor：设置网络拦截器，主要用于重试或重写
